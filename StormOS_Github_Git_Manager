#!/usr/bin/env python3

import os
import sys
import json
import requests
import shutil
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QLabel, QLineEdit, QPushButton, QTextBrowser,
    QVBoxLayout, QWidget, QMessageBox, QComboBox, QHBoxLayout, QProgressBar
)
from PyQt5.QtCore import QSize, Qt, QThread, pyqtSignal
from git import Repo, GitCommandError


class CloneThread(QThread):
    """
    Thread to handle cloning repositories without freezing the UI.
    """
    progress = pyqtSignal(str)
    finished = pyqtSignal(bool, str)

    def __init__(self, repo_url, local_path, parent=None):
        super().__init__(parent)
        self.repo_url = repo_url
        self.local_path = local_path

    def run(self):
        try:
            self.progress.emit("Cloning repository...")
            Repo.clone_from(self.repo_url, self.local_path)
            self.progress.emit("Repository cloned successfully.")
            self.finished.emit(True, "Cloning completed.")
        except GitCommandError as e:
            self.finished.emit(False, f"Error cloning repository: {e}")
        except Exception as e:
            self.finished.emit(False, f"Unexpected error: {e}")


class PushThread(QThread):
    """
    Thread to handle pushing changes to the remote repository without freezing the UI.
    """
    progress = pyqtSignal(str)
    finished = pyqtSignal(bool, str)

    def __init__(self, repo_path, parent=None):
        super().__init__(parent)
        self.repo_path = repo_path

    def run(self):
        try:
            self.progress.emit("Pushing changes to remote...")
            repo = Repo(self.repo_path)
            origin = repo.remote(name='origin')
            origin.push()
            self.progress.emit("Changes pushed to remote successfully.")
            self.finished.emit(True, "Push completed.")
        except GitCommandError as e:
            self.finished.emit(False, f"Error pushing changes: {e}")
        except Exception as e:
            self.finished.emit(False, f"Unexpected error: {e}")


class GitHubGitClient(QMainWindow):
    """
    A simplified PyQt5-based GitHub Git Client that allows users to perform essential Git operations
    and interact with GitHub repositories through a graphical interface.
    """

    def __init__(self):
        super().__init__()
        self.initUI()

        # Initialize repository path
        self.repo_path = None

        # Set default cloning directory
        self.default_clone_dir = os.path.expanduser("~/Documents/GitHub")
        os.makedirs(self.default_clone_dir, exist_ok=True)

        # Initialize progress bar
        self.progress_bar = QProgressBar(self)
        self.statusBar().addPermanentWidget(self.progress_bar)
        self.progress_bar.setVisible(False)

        # Load GitHub token and Git credentials from configuration files
        self.load_git_credentials()

    def initUI(self):
        """Set up the user interface."""
        self.setWindowTitle('GitHub Git Client')
        self.setGeometry(100, 100, 600, 400)

        # Create central widget and layout
        central_widget = QWidget(self)
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)

        # GitHub Username and PAT Input
        input_layout = QHBoxLayout()
        self.username_label = QLabel('GitHub Username:')
        self.username_input = QLineEdit(self)
        input_layout.addWidget(self.username_label)
        input_layout.addWidget(self.username_input)

        self.token_label = QLabel('Personal Access Token:')
        self.token_input = QLineEdit(self)
        self.token_input.setEchoMode(QLineEdit.Password)
        input_layout.addWidget(self.token_label)
        input_layout.addWidget(self.token_input)

        layout.addLayout(input_layout)

        # Fetch Repositories Button
        fetch_repos_button = QPushButton('Fetch Repositories', self)
        fetch_repos_button.clicked.connect(self.fetch_repositories)
        layout.addWidget(fetch_repos_button)

        # Repository Selection ComboBox
        self.repo_combo_box = QComboBox(self)
        layout.addWidget(self.repo_combo_box)

        # Clone Repository Button
        clone_repo_button = QPushButton('Clone Repository', self)
        clone_repo_button.clicked.connect(self.initiate_clone_repository)
        layout.addWidget(clone_repo_button)

        # Commit Message Input and Commit Button
        commit_layout = QHBoxLayout()
        self.commit_input = QLineEdit(self)
        self.commit_input.setPlaceholderText("Enter commit message")
        commit_button = QPushButton('Commit Changes', self)
        commit_button.clicked.connect(self.commit_changes)
        commit_layout.addWidget(self.commit_input)
        commit_layout.addWidget(commit_button)
        layout.addLayout(commit_layout)

        # Push Changes Button
        push_button = QPushButton('Push Changes', self)
        push_button.clicked.connect(self.push_changes)
        layout.addWidget(push_button)

        # Text Browser for Displaying Messages
        self.repo_details_browser = QTextBrowser(self)
        layout.addWidget(self.repo_details_browser)

    def display_message(self, message):
        """
        Display a message in the repository details browser.

        Args:
            message (str): The message to display.
        """
        self.repo_details_browser.append(message)
        # Scroll to the bottom of the QTextBrowser
        scrollbar = self.repo_details_browser.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def save_git_credentials(self, username, token):
        """
        Save Git credentials to a JSON file in the user's home directory.

        Args:
            username (str): GitHub username.
            token (str): GitHub Personal Access Token (PAT).
        """
        credentials = {'username': username, 'token': token}
        credentials_dir = os.path.expanduser("~/Documents/GitHubGitClient")
        os.makedirs(credentials_dir, exist_ok=True)
        credentials_file = os.path.join(credentials_dir, "github_credentials.json")
        try:
            with open(credentials_file, 'w') as file:
                json.dump(credentials, file)
            self.display_message("GitHub credentials saved successfully.")
        except Exception as e:
            self.display_message(f"Error saving Git credentials: {e}")

    def load_git_credentials(self):
        """
        Load Git credentials from the JSON file if it exists.
        """
        credentials_file = os.path.expanduser("~/Documents/GitHubGitClient/github_credentials.json")
        if os.path.exists(credentials_file):
            try:
                with open(credentials_file, 'r') as file:
                    credentials = json.load(file)
                    self.username_input.setText(credentials['username'])
                    self.token_input.setText(credentials['token'])
                    self.github_token = credentials['token']
                self.display_message("GitHub credentials loaded successfully.")
            except Exception as e:
                self.display_message(f"Error loading Git credentials: {e}")
        else:
            self.display_message("GitHub credentials file not found.")

    def fetch_repositories(self):
        """
        Fetch the list of GitHub repositories for the user and populate the combo box.
        """
        username = self.username_input.text()
        self.github_token = self.token_input.text()

        if not username or not self.github_token:
            QMessageBox.warning(self, "Warning", "Please enter your GitHub username and Personal Access Token (PAT).")
            return

        try:
            # Create a session and authenticate with GitHub using the token
            session = requests.Session()
            session.headers["Authorization"] = f"token {self.github_token}"

            # Fetch the list of user repositories
            response = session.get(f"https://api.github.com/users/{username}/repos")

            if response.status_code == 200:
                repositories = response.json()
                if repositories:
                    repo_names = [repo["name"] for repo in repositories]
                    self.repo_combo_box.clear()
                    self.repo_combo_box.addItems(repo_names)
                    self.repo_combo_box.setEnabled(True)
                    self.display_message("Repositories fetched successfully. Select a repository to clone.")
                else:
                    self.display_message("No repositories found.")
            else:
                error_message = response.json().get("message", "Unknown error")
                self.display_message(f"Failed to fetch repositories. Status code: {response.status_code}. Message: {error_message}")
        except Exception as e:
            self.display_message(f"Error fetching repositories: {e}")

    def initiate_clone_repository(self):
        """
        Initiate the cloning process by selecting a repository and cloning it asynchronously.
        """
        repo_name = self.repo_combo_box.currentText()
        if not repo_name:
            self.display_message("Please select a repository to clone.")
            return

        # Construct the repository URL with authentication
        username = self.username_input.text()
        token = self.token_input.text()

        if not username or not token:
            self.display_message("Please enter your GitHub username and Personal Access Token (PAT).")
            return

        repo_url = f"https://{username}:{token}@github.com/{username}/{repo_name}.git"

        # Set the local path with the default cloning directory
        local_path = os.path.join(self.default_clone_dir, repo_name)

        # Check if the directory already exists
        if os.path.exists(local_path):
            QMessageBox.warning(self, "Warning", f"The directory '{local_path}' already exists.")
            return

        # Start the cloning thread
        self.clone_thread = CloneThread(repo_url, local_path)
        self.clone_thread.progress.connect(self.update_progress)
        self.clone_thread.finished.connect(self.handle_clone_finished)
        self.clone_thread.start()

        # Show the progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 0)  # Indeterminate state

    def handle_clone_finished(self, success, message):
        """
        Handle the completion of the cloning process.

        Args:
            success (bool): Indicates if cloning was successful.
            message (str): Success or error message.
        """
        self.progress_bar.setVisible(False)
        self.display_message(message)
        if success:
            self.repo_path = os.path.join(self.default_clone_dir, self.repo_combo_box.currentText())
            self.display_message(f"Repository path set to: {self.repo_path}")

    def commit_changes(self):
        """
        Commit staged changes with a user-provided commit message using GitPython.
        """
        commit_message = self.commit_input.text().strip()

        if not commit_message:
            QMessageBox.warning(self, "Warning", "Please enter a commit message.")
            return

        if not self.repo_path:
            self.display_message("Please clone a repository first.")
            return

        try:
            repo = Repo(self.repo_path)
            if repo.is_dirty(index=True, working_tree=True, untracked_files=True):
                repo.git.commit('-m', commit_message)
                self.display_message(f"Changes committed with message: {commit_message}")
                self.commit_input.clear()
            else:
                self.display_message("No changes to commit.")
        except GitCommandError as e:
            self.display_message(f"Error committing changes: {e}")
        except Exception as e:
            self.display_message(f"Unexpected error committing changes: {e}")

    def push_changes(self):
        """
        Push committed changes to the remote repository using GitPython.
        """
        if not self.repo_path:
            self.display_message("Please clone a repository first.")
            return

        # Start the push thread
        self.push_thread = PushThread(self.repo_path)
        self.push_thread.progress.connect(self.update_progress)
        self.push_thread.finished.connect(self.handle_push_finished)
        self.push_thread.start()

        # Show the progress bar
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 0)  # Indeterminate state

    def handle_push_finished(self, success, message):
        """
        Handle the completion of the push process.

        Args:
            success (bool): Indicates if pushing was successful.
            message (str): Success or error message.
        """
        self.progress_bar.setVisible(False)
        self.display_message(message)

    def update_progress(self, message):
        """
        Update the progress bar with a message.

        Args:
            message (str): Progress message.
        """
        self.display_message(message)

    def view_repository_contents(self):
        """
        Display the contents of the repository in the text browser.
        """
        if not self.repo_path:
            self.display_message("Please clone a repository first.")
            return

        try:
            repo = Repo(self.repo_path)
            contents = repo.git.ls_files().split('\n')  # List the files in the repository

            if contents and contents != ['']:
                content_text = "\n".join(contents)
                self.repo_details_browser.setPlainText(content_text)
            else:
                self.repo_details_browser.setPlainText("No contents found in the repository.")
        except GitCommandError as e:
            self.display_message(f"Error fetching repository contents: {e}")
        except Exception as e:
            self.display_message(f"Unexpected error fetching repository contents: {e}")


def main():
    """Initialize and run the GitHub Git Client application."""
    app = QApplication(sys.argv)
    window = GitHubGitClient()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()
