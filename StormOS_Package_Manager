#!/usr/bin/env python3

import gi
gi.require_version("Gtk", "3.0")
gi.require_version('Vte', '2.91')
from gi.repository import Gtk, Vte, GLib, Gio, Gdk
import os
import shutil
import subprocess

class ProgramInstaller(Gtk.Window):
    def __init__(self):
        Gtk.Window.__init__(self, title="StormOS Package Manager")

        # Dynamically get screen size using Gdk.Display and Gdk.Monitor
        display = Gdk.Display.get_default()
        monitor = display.get_primary_monitor()
        geometry = monitor.get_geometry()

        screen_width = geometry.width
        screen_height = geometry.height

        # Set a default size and a maximum size that doesn't fill the entire screen
        default_width = min(1100, int(screen_width * 0.75))
        default_height = min(700, int(screen_height * 0.75))

        self.set_default_size(default_width, default_height)
        self.set_size_request(800, 600)  # Minimum size to ensure it's usable on smaller screens

        # Create a grid layout for better organization of widgets
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)
        grid.set_hexpand(True)
        grid.set_vexpand(True)
        self.add(grid)

        # Default list of built-in programs to install/uninstall
        self.built_in_programs = [
            "rustdesk-bin", "discord", "google-chrome", "vdhcoapp",
            "signal-desktop", "warpinator", "gimp",
            "sublime-text-4", "onlyoffice-bin", "xdman-beta-bin", "zoom"
        ]

        # Dictionary to hold the checkbox widgets for each program
        self.program_checkboxes = {}

        # "Check All" checkbox
        self.check_all_checkbox = Gtk.CheckButton(label="Select/Deselect All Built-in Programs")
        self.check_all_checkbox.connect("toggled", self.on_check_all_toggled)
        grid.attach(self.check_all_checkbox, 0, 0, 2, 1)

        # Grid layout for selectable program checkboxes (2 columns of 5 programs each)
        program_grid = Gtk.Grid()
        program_grid.set_column_spacing(20)
        program_grid.set_row_spacing(5)
        grid.attach(program_grid, 0, 1, 2, 2)

        # Create individual checkboxes for each built-in program, arranged in 2 columns
        for idx, program in enumerate(self.built_in_programs):
            checkbox = Gtk.CheckButton(label=program)
            checkbox.set_active(False)
            row = idx % 5
            col = idx // 5
            program_grid.attach(checkbox, col, row, 1, 1)
            self.program_checkboxes[program] = checkbox

        # Checkbox to include or ignore programs from programs.txt
        self.include_programs_file_checkbox = Gtk.CheckButton(label="Include programs from programs.txt")
        self.include_programs_file_checkbox.set_active(False)  # Unchecked by default
        grid.attach(self.include_programs_file_checkbox, 0, 3, 2, 1)

        # Text entry for adding custom programs or entering search queries
        self.entry = Gtk.Entry()
        self.entry.set_placeholder_text("Enter programs separated by a comma, or search")
        grid.attach(self.entry, 0, 4, 2, 1)

        # Create a scrolled window for the terminal widget
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_vexpand(True)  # Allow vertical expansion
        scrolled_window.set_hexpand(True)  # Allow horizontal expansion

        # Terminal widget using Vte to display live command output
        self.terminal = Vte.Terminal()
        self.terminal.set_scrollback_lines(10000)
        self.terminal.set_rewrap_on_resize(True)

        # Add terminal widget to the scrolled window
        scrolled_window.add(self.terminal)

        # Attach the scrolled window to the grid
        grid.attach(scrolled_window, 2, 0, 6, 6)

        # Prepare the environment and command for the terminal
        envv = [f'{key}={value}' for key, value in os.environ.items()]  # Correctly format environment variables
        working_dir = os.environ['HOME']  # Set the working directory
        command = ["/bin/bash"]  # Command to run in the terminal

        # Create a Gio.Cancellable object
        self.cancellable = Gio.Cancellable()

        # Spawn a shell in the terminal with all required arguments, including timeout
        self.terminal.spawn_async(
            Vte.PtyFlags.DEFAULT,               # pty_flags
            working_dir,                        # working_directory
            command,                            # argv
            envv,                               # envv
            GLib.SpawnFlags.DEFAULT,            # spawn_flags
            None,                               # child_setup
            None,                               # child_setup_data
            -1,                                 # timeout (in milliseconds, -1 for default)
            self.cancellable,                   # cancellable
            self.on_terminal_spawned,           # callback
            None                                # user_data
        )

        # Bind keyboard shortcuts for copy and paste
        self.connect("key-press-event", self.on_key_press_event)

        # Create a right-click context menu for mouse-based copy and paste
        self.context_menu = Gtk.Menu()

        # Copy menu item
        copy_item = Gtk.MenuItem(label="Copy")
        copy_item.connect("activate", self.on_copy_activate)
        self.context_menu.append(copy_item)

        # Paste menu item
        paste_item = Gtk.MenuItem(label="Paste")
        paste_item.connect("activate", self.on_paste_activate)
        self.context_menu.append(paste_item)

        self.context_menu.show_all()

        # Connect mouse right-click event to show context menu
        self.terminal.connect("button-press-event", self.on_button_press)

        # Radio buttons for search options: Pacman, AUR, or Both
        self.search_option_label = Gtk.Label(label="Search Options:")
        grid.attach(self.search_option_label, 0, 6, 1, 1)

        self.pacman_radio = Gtk.RadioButton.new_with_label_from_widget(None, "Search Pacman")
        self.aur_radio = Gtk.RadioButton.new_with_label_from_widget(self.pacman_radio, "Search AUR")
        self.both_radio = Gtk.RadioButton.new_with_label_from_widget(self.pacman_radio, "Search Both")

        grid.attach(self.pacman_radio, 1, 6, 1, 1)
        grid.attach(self.aur_radio, 2, 6, 1, 1)
        grid.attach(self.both_radio, 3, 6, 1, 1)

        # Create Programs File button
        self.create_programs_file_button = Gtk.Button(label="Create programs.txt")
        self.create_programs_file_button.connect("clicked", self.create_default_programs_file)
        grid.attach(self.create_programs_file_button, 0, 7, 1, 1)

        # File selector button
        self.file_button = Gtk.Button(label="Select Programs File")
        self.file_button.connect("clicked", self.on_file_button_clicked)
        grid.attach(self.file_button, 1, 7, 1, 1)

        # Update System button
        self.update_button = Gtk.Button(label="Update System")
        self.update_button.connect("clicked", self.on_update_button_clicked)
        grid.attach(self.update_button, 0, 8, 1, 1)

        # Install button
        self.install_button = Gtk.Button(label="Install Programs")
        self.install_button.connect("clicked", self.on_install_button_clicked)
        grid.attach(self.install_button, 1, 8, 1, 1)

        # Uninstall button
        self.uninstall_button = Gtk.Button(label="Uninstall Programs")
        self.uninstall_button.connect("clicked", self.on_uninstall_button_clicked)
        grid.attach(self.uninstall_button, 2, 8, 1, 1)

        # Search button
        self.search_button = Gtk.Button(label="Search Packages")
        self.search_button.connect("clicked", self.on_search_button_clicked)
        grid.attach(self.search_button, 3, 8, 1, 1)

        # Close button
        self.close_button = Gtk.Button(label="Close")
        self.close_button.connect("clicked", self.on_close_button_clicked)
        grid.attach(self.close_button, 4, 8, 1, 1)

    def on_terminal_spawned(self, terminal, pid, error, user_data):
        """Callback for terminal spawn completion."""
        if error:
            print(f"Failed to spawn terminal: {error.message}")
        else:
            print(f"Terminal spawned successfully with PID: {pid}")
            # Send a test command to verify the terminal is working
            test_command = "echo 'Terminal initialized successfully.'\n"
            self.terminal.feed_child(test_command.encode("utf-8"))

    def on_key_press_event(self, widget, event):
        """Handle keyboard shortcuts for copy and paste."""
        keyname = Gdk.keyval_name(event.keyval)
        state = event.state & Gtk.accelerator_get_default_mod_mask()

        # Ctrl + Shift + C for copy
        if keyname == 'C' and state == Gdk.ModifierType.CONTROL_MASK | Gdk.ModifierType.SHIFT_MASK:
            self.terminal.copy_clipboard()

        # Ctrl + Shift + V for paste
        elif keyname == 'V' and state == Gdk.ModifierType.CONTROL_MASK | Gdk.ModifierType.SHIFT_MASK:
            self.terminal.paste_clipboard()

    def on_button_press(self, widget, event):
        """Show context menu on right-click (mouse button 3)."""
        if event.button == 3:  # Right-click
            self.context_menu.popup(None, None, None, None, event.button, event.time)
            return True  # Prevent further event handling
        return False

    def on_copy_activate(self, widget):
        """Handle copy activation from the context menu."""
        self.terminal.copy_clipboard()

    def on_paste_activate(self, widget):
        """Handle paste activation from the context menu."""
        self.terminal.paste_clipboard()

    def create_default_programs_file(self, widget=None):
        """Create the default 'programs.txt' file on the user's Desktop."""
        # Get the user's home directory and construct the Desktop path
        desktop_dir = os.path.join(os.environ['HOME'], 'Desktop')

        # Ensure the Desktop directory exists
        if not os.path.exists(desktop_dir):
            os.makedirs(desktop_dir)

        # Set the path for the programs.txt file on the Desktop
        programs_file = os.path.join(desktop_dir, "programs.txt")

        # Write the default content to the programs.txt file
        with open(programs_file, "w") as file:
            file.write("# Add one program per line\n")
            file.write("# Lines starting with '#' are comments and will be ignored\n")
            file.write("# Example programs are commented out on purpose to avoid installing or removing\n")
            file.write("#firefox\n")
            file.write("#vlc\n")

        # Use echo to inform the user in the terminal
        message = f"Created/overwritten 'programs.txt' on the Desktop at {programs_file}\n"
        self.terminal.feed_child(f"echo '{message.strip()}'\n".encode("utf-8"))

    def load_additional_programs(self, programs_file=None):
        """Load additional programs from 'programs.txt' or a selected file."""
        if not programs_file:
            script_dir = os.path.dirname(os.path.abspath(__file__))
            programs_file = os.path.join(script_dir, "programs.txt")

        if os.path.exists(programs_file):
            with open(programs_file, "r") as file:
                additional_programs = [line.strip() for line in file if line.strip() and not line.startswith("#")]
                if additional_programs:
                    message = f"Loaded programs from {programs_file}: {', '.join(additional_programs)}"
                    self.terminal.feed_child(f"echo '{message}'\n".encode("utf-8"))
                    self.loaded_programs = additional_programs  # Store the loaded programs
                else:
                    message = f"The '{programs_file}' file is empty."
                    self.terminal.feed_child(f"echo '{message}'\n".encode("utf-8"))
        else:
            message = f"The '{programs_file}' file was not found."
            self.terminal.feed_child(f"echo '{message}'\n".encode("utf-8"))

    def on_file_button_clicked(self, widget):
        """Handle file selection dialog to choose a custom programs.txt file."""
        dialog = Gtk.FileChooserDialog(
            title="Select Programs File", parent=self,
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_text = Gtk.FileFilter()
        filter_text.set_name("Text files")
        filter_text.add_mime_type("text/plain")
        dialog.add_filter(filter_text)

        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            selected_file = dialog.get_filename()
            message = f"Selected file: {selected_file}"
            self.terminal.feed_child(f"echo '{message}'\n".encode("utf-8"))
            self.load_additional_programs(programs_file=selected_file)

        dialog.destroy()

    def on_check_all_toggled(self, widget):
        """Toggle all individual checkboxes when 'Check All' is toggled."""
        is_checked = widget.get_active()
        for checkbox in self.program_checkboxes.values():
            checkbox.set_active(is_checked)

    def on_install_button_clicked(self, widget):
        """Install selected programs."""
        self.run_selected_programs("install")

    def on_uninstall_button_clicked(self, widget):
        """Uninstall selected programs."""
        self.run_selected_programs("uninstall")

    def on_search_button_clicked(self, widget):
        """Search for multiple packages based on the selected search option."""

        # Get the text entered in the entry field
        search_query = self.entry.get_text().strip()

        # Collect programs from programs.txt if selected
        if self.include_programs_file_checkbox.get_active():
            search_query += ", " + ", ".join(self.loaded_programs)

        # Split the search query by commas and strip any leading/trailing spaces
        queries = [query.strip() for query in search_query.split(",") if query.strip()]

        if queries:
            # Check which search option is selected (Pacman, AUR, or Both)
            if self.pacman_radio.get_active():
                for query in queries:
                    self.search_programs_in_pacman(query)
            elif self.aur_radio.get_active():
                for query in queries:
                    self.search_programs_in_aur(query)
            elif self.both_radio.get_active():
                for query in queries:
                    self.search_programs_in_pacman_and_yay(query)
        else:
            message = "Please enter a search query."
            self.terminal.feed_child(f"echo '{message}'\n".encode("utf-8"))

    def search_programs_in_pacman(self, query):
        """Search for a package using pacman in the official repositories."""
        pacman_command = f"pacman -Ss {query}\n"
        self.terminal.feed_child(f"echo 'Searching for \"{query}\" in official repositories...'\n".encode("utf-8"))
        self.terminal.feed_child(pacman_command.encode("utf-8"))

    def search_programs_in_aur(self, query):
        """Search for a package using yay in the AUR."""
        yay_command = f"yay -Ssa {query}\n"
        self.terminal.feed_child(f"echo 'Searching for \"{query}\" in AUR...'\n".encode("utf-8"))
        self.terminal.feed_child(yay_command.encode("utf-8"))

    def search_programs_in_pacman_and_yay(self, query):
        """Search for a package using pacman first, and then yay if not found in the official repos."""
        self.search_programs_in_pacman(query)
        self.search_programs_in_aur(query)

    def clear_yay_cache(self, program):
        """Clear the yay cache for a specific program."""
        cache_dir = f"/var/cache/yay/{program}"
        if os.path.exists(cache_dir):
            try:
                shutil.rmtree(cache_dir)  # Remove the cache directory
                self.terminal.feed_child(f"echo 'Cleared cache for {program}'\n".encode("utf-8"))
            except Exception as e:
                self.terminal.feed_child(f"echo 'Failed to clear cache for {program}: {str(e)}'\n".encode("utf-8"))

    def is_package_installed(self, package_name):
        """Check if a package is installed using pacman."""
        try:
            result = subprocess.run(
                ['pacman', '-Q', package_name],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            return result.returncode == 0
        except Exception as e:
            return False

    def run_selected_programs(self, action):
        """Run the selected programs for either installation or uninstallation."""
        selected_programs_to_run = []

        # Check if programs from 'programs.txt' are included
        if self.include_programs_file_checkbox.get_active() and self.loaded_programs:
            selected_programs_to_run.extend(self.loaded_programs)

        # Add selected built-in programs from the checkboxes
        for program, checkbox in self.program_checkboxes.items():
            if checkbox.get_active():
                selected_programs_to_run.append(program)

        # Add additional programs from the text field (split by commas)
        additional_programs_from_gui = self.entry.get_text().strip()
        if additional_programs_from_gui:
            additional_programs = [prog.strip() for prog in additional_programs_from_gui.split(",") if prog.strip()]
            selected_programs_to_run.extend(additional_programs)

        # Remove duplicates
        selected_programs_to_run = list(set(selected_programs_to_run))

        if selected_programs_to_run:
            aur_packages_list = [
                "rustdesk-bin", "discord", "google-chrome", "vdhcoapp", 
                "signal-desktop", "warpinator", "sublime-text-4", 
                "onlyoffice-bin", "xdman-beta-bin", "zoom"
            ]

            # Separate AUR packages from system packages
            aur_packages = [pkg for pkg in selected_programs_to_run if pkg in aur_packages_list]
            system_packages = [pkg for pkg in selected_programs_to_run if pkg not in aur_packages_list]

            if aur_packages:
                if action == "install":
                    aur_command = f"yay -S {' '.join(aur_packages)} --noconfirm\n"
                elif action == "uninstall":
                    aur_command = f"yay -Rns {' '.join(aur_packages)} --noconfirm\n"

                self.terminal.feed_child(f"echo '{action.capitalize()}ing AUR packages: {', '.join(aur_packages)}'\n".encode('utf-8'))
                self.terminal.feed_child(aur_command.encode("utf-8"))

            if system_packages:
                packages_to_process = []
                for pkg in system_packages:
                    if action == "uninstall":
                        if self.is_package_installed(pkg):
                            packages_to_process.append(pkg)
                        else:
                            self.terminal.feed_child(f"echo 'Package {pkg} is not installed, skipping...'\n".encode("utf-8"))
                    else:
                        packages_to_process.append(pkg)

                if packages_to_process:
                    if action == "install":
                        system_command = f"pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY pacman -S {' '.join(packages_to_process)} --noconfirm\n"
                    elif action == "uninstall":
                        system_command = f"pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY pacman -Rns {' '.join(packages_to_process)} --noconfirm\n"

                    self.terminal.feed_child(f"echo '{action.capitalize()}ing system packages: {', '.join(packages_to_process)}'\n".encode('utf-8'))
                    self.terminal.feed_child(system_command.encode("utf-8"))
                else:
                    self.terminal.feed_child(f"echo 'No system packages found for {action}.'\n".encode("utf-8"))
        else:
            self.terminal.feed_child("echo 'No programs selected for installation or uninstallation.'\n".encode("utf-8"))

    def on_update_button_clicked(self, widget):
        """Update the system using yay with pkexec for graphical sudo prompt."""
        update_command = "pkexec yay -Syyu --noconfirm\n"
        print(f"Executing: {update_command}")  # Debugging
        self.terminal.feed_child(f"echo 'Updating system...'\n".encode("utf-8"))
        self.terminal.feed_child(update_command.encode("utf-8"))

    def on_close_button_clicked(self, widget):
        """Close the application when the close button is clicked."""
        Gtk.main_quit()

# Running the GTK application
if __name__ == "__main__":
    win = ProgramInstaller()
    win.connect("destroy", Gtk.main_quit)
    win.show_all()
    Gtk.main()
